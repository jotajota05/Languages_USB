module Main (main) where

import System
import System.IO 
import IO
import Directory

-- DEFINICION DE TIPOS DE DATOS

data Value = I Int | B Bool | F Float | C Char | St String 
             deriving (Eq,Show)

data Term = Const Value
          | Var String
          | Fun String [Term]
            deriving (Eq,Show)
                     
type Atom = (String,[Term])

type Tail = [Atom]

data Question = Q Tail 
                deriving (Eq,Show)

data Definite = Fact Atom
              | Rule Atom Tail
                deriving (Eq,Show)

data Program = Prolog [Definite] 
               deriving (Eq,Show)

data Subs = S [(Term,Term)] 
          | E String 
            deriving (Eq,Show)

-- FUNCIONES

--Funcion que aplica una sustitucion a una lista de atomos

mult_sustitucion :: Subs -> [Atom] -> [Atom]
mult_sustitucion _ [] = []
mult_sustitucion (S ss) (x:xs) = (sustitucion x (S ss)):(mult_sustitucion (S ss) xs)
mult_sustitucion (E _) _ = []

-- Sustitucion

sustitucion :: Atom -> Subs -> Atom
sustitucion atomo (E _) = atomo
sustitucion (nom,ts) (S ss) = (nom,map (sustit (S ss)) ts)

-- Funci�n que realiza la sustitucion a nivel de t�rminos

sustit :: Subs -> Term -> Term
sustit (E _) term = term
sustit (S []) term = term
sustit (S ss) (Var x) | (isVar (fst (head ss)) && (fst (head ss)) == Var x) = (snd (head ss))
                      | otherwise = sustit (S (tail ss)) (Var x)
sustit (S ss) (Fun m rs) = Fun m (map (sustit (S ss)) rs)
sustit (S ss) (Const v) = Const v

--Funcion que verifica si un termino es una variable

isVar:: Term -> Bool
isVar (Var x) = True
isVar _ = False

-- Robinson

robinson :: Atom -> Atom -> Subs
robinson (nom,ts) (mon,st) | (nom /= mon) = E "Error Predicados distintos"
                           | (length ts /= length st) = E "Error Aridades distintas"
                           | otherwise = alan (pares ts st)

pares :: [Term] -> [Term] -> [(Term,Term)]
pares [] [] = []
pares (t:ts) (r:rs) = (t,r) : pares ts rs

alan :: [(Term,Term)] -> Subs
alan ((Const v,Const w):terms) = E "Error Constantes"

alan ((Const v,Var x):terms) | (length terms > 0 ) = catsub (S [(Var x,Const v)]) (alan terms)
                             | otherwise =  S [(Var x,Const v)]
alan ((Const v,Fun f rs):terms) = E "Error Constante - Funcion"

alan (((Fun f xs),(Fun g ys)):terms) | (f/=g) = E "Error Funciones distintas"
                                     | (length xs /= length ys) = E "Error Aridades de funciones distintas"
                                     | otherwise = alan ((pares xs ys) ++ terms)
alan (((Fun f xs),Var x):terms) | occurs_check (Var x) (Fun f xs) = E "Error Variable - Funcion"
                                | (length terms == 0) = S [(Var x,Fun f xs)]
                                | otherwise  = catsub (S [(Var x,Fun f xs)]) (alan (map (sustituirPar (S [(Var x,Fun f xs)])) (terms)))

alan (((Fun f xs),Const v):terms) = E "Error Funcion - COnstante"

alan ((Var x,Var y):terms) | (length terms > 0) = catsub (S [(Var x,Var y)]) (alan (map (sustituirPar (S [(Var x,Var y)])) (terms)))
                           | otherwise = S [(Var x,Var y)]
alan ((Var x,(Fun f xs)):terms) | occurs_check (Var x) (Fun f xs) = E "Error Variable - Funcion"
                                | (length terms == 0) = S [(Var x,Fun f xs)]
                                | otherwise  = catsub (S [(Var x,Fun f xs)]) (alan (map (sustituirPar (S [(Var x,Fun f xs)])) (terms)))
                                            
alan ((Var x,Const v):terms) | (length terms > 0 ) = catsub (S [(Var x,Const v)]) (alan (map (sustituirPar (S [(Var x,Const v)])) (terms)))
                             | otherwise =  S [(Var x,Const v)]

sustituirPar :: Subs -> (Term,Term) -> (Term,Term)
sustituirPar (S ss) (x,y) = (sustit (S ss) x,sustit (S ss) y) 

catsub :: Subs -> Subs -> Subs
catsub (E e1) (E e2) = E (e1 ++ " y " ++ e2)
catsub (E e) _  = (E e)
catsub _ (E e)  = (E e)
catsub (S ts) (S st) = S (ts ++ st)

occurs_check :: Term -> Term -> Bool
occurs_check (Var x) (Fun m rs) = pertenece (Var x) rs
occurs_check (Fun m rs) (Var x) = occurs_check (Var x) (Fun m rs)
occurs_check _ _ = False
                   
pertenece :: Term -> [Term] -> Bool
pertenece t [] = False
pertenece (Var x) ((Var y):rs) = if x==y then True else False
pertenece (Var x) ((Fun f ts):rs) = (or (map (occurs_check (Var x)) ts)) || pertenece (Var x) rs
pertenece _ _ = False

{-
Funcion @resolucion@ 
Parametros de entrada: 1 pregunta; 1 programa
Salida: Una lista de todas las sustituciones que se deben hacer a un programa para obtener un resolvente igual a la meta clausula vacia.
La funcion 
-}
resolucion :: Question -> Program -> Subs
resolucion (Q []) (Prolog _) = S [] --Caso de la meta clausula vacia false.
resolucion (Q question) (Prolog program) = 
    let clause = (clauseUni program (head question))
        robin = robinson (catchAtom clause) (head question)
        resolvente = mult_sustitucion robin ((catchTail clause)++(tail question)) 
    in S ((subsToList robin) ++ (subsToList (resolucion (Q resolvente) (Prolog program))))

{-
Funcion: @clauseUni@
Parametros de entrada: 1 Lista de clausulas "definite" ; 1 atomo
Salida: clauseUni devuelve la primera clausula definite de la lista que sea unificable con el atomo.
La funcion es utilizada en la funcion resolucion para determinar el primer atomo de un programa que sea unificable con el primer atomo del parametro de entrada de resolucion correspondiente a una pregunta.
-}
clauseUni :: [Definite] -> Atom -> Definite
clauseUni [] _= Fact ("nulo",[])
clauseUni (x:xs) (str,ts) = 
   let robin = (robinson (catchAtom x) (str,ts)) in if (catchError robin) 
                                                    then (clauseUni xs (str,ts))
                                                    else x
{-
Funcion: @subsToList@
Parametros de Entrada: Un tipo de datos susutitucion (Subs)
Salida: La lista [(Term,Term)] correspondiente a subs
En el caso de que subs sea una lista de tuplas de terminos, la funcion retorna es lista. En el caso de que subs sea un error, la funcion retorna la lista vacia. 
-}
subsToList :: Subs -> [(Term,Term)]
subsToList (S ss) = ss
subsToList (E _) = []

{-Funcion: @catchAtom@
Parametro de entrada: Un tipo de clausula definite
Salida: el atomo positivo de la clausula
Esta funcion se creo para poder acceder al atomo de una clausula definite independientemente de que la clausula sea una regla o un hecho. Como todas las clausulas definite tienen uno y solo un atomo positivo, la funcion funciona bajo el dominio de todas las clausulas definite.
-}
catchAtom :: Definite -> Atom
catchAtom (Fact at) = at
catchAtom (Rule at _) = at

{-Funcion: @catchTail@
Parametro de entrada: Un tipo de clausula definite
Salida: La lista de atomos negativos correspondientes a la clausula.
En el caso de que la clausula de entrada sea una regla la funcion retorna la lista de atomos negativos asociada a esa regla. En el caso de que la clausula sea un hecho, la funcion retorna una lista vacia.
-}
catchTail :: Definite -> Tail
catchTail (Rule _ tail) = tail
catchTail (Fact _) = []

{-Funcion @catchError@
Parametro de Entrada: Un tipo de datos Subs
Salida: Bool
La funcion devuelve True en el caso de que subs corresponda a un error y retorna False en el caso de que subs corresponda a una lista de tuplas de terminos.
-}
catchError :: Subs -> Bool
catchError(E string) = True
catchError(S ss) = False


-- EJEMPLOS PARA CHEQUEAR LAS FUNCIONES
-- ejemplos de data

app :: Program
app = Prolog [Fact ("append",[Fun "lista" [],Var "L",Var "L"]), Rule ("append",[Fun "lista" [Var "A",Var"X"],Var "Y",Fun "lista" [Var "A",Var "Z"]])[("append",[Var "X",Var "Y",Var "Z"])]]

query :: Question
query = Q [("append",[Fun "lista" [Var "Head",Var "Tail1"],Var "Tail2",Fun "lista" [Const (C 'a'),Fun "list" []]])]

poesia :: Program
poesia = Prolog [Rule ("poesia",[Var "X1",Var "Y1"]) [("inspiracion",[Var "X1",Var "Y1"]),("oficio",[Var "X1"]),("talento",[Var "X1"])],
                 Rule ("inspiracion",[Var "X2",Var "Y2"]) [("musa",[Const (St "erato"),Var "X2"]),("idea",[Var "Y2"])],
                 Rule ("oficio",[Var "X3"]) [("practica",[Var "X3"])],
                 Fact ("musa",[Const (St "erato"),Const (St "luis")]),
                 Fact ("musa",[Const (St "erato"),Const (St "kavafis")]),
                 Fact ("idea",[Const (St "itaca")]),
                 Fact ("practica",[Const (St "luis")]),
                 Fact ("practica",[Const (St "kavafis")]),
                 Fact ("talento",[Const (St "kavafis")])]

preg :: Question
preg = Q [("poesia",[Const (St "kavafis"),Var "T"]),("poesia",[Var "K",Const (St "itaca")]) ]

-- ejemplo para la funci?n sustituci?n

atomo :: Atom
atomo = ("append",[Fun "lista" [Var "A",Var"X"],Var "Y",Fun "lista" [Var "A",Var "Z"]])

sust_ejem :: Subs
sust_ejem = S [(Var "A",Const (C 'a')),(Var "X",Fun "lista" [])]

-- ejemplo para la funci?n robinson


atomo1 :: Atom
atomo1 = ("append",[Fun "lista" [Var "A",Var"X"],Var "Y",Fun "lista" [Var "A",Var "Z"]])

atomo2 :: Atom
atomo2 = ("append",[Fun "lista" [Var "Head",Var "Tail1"],Var "Tail2",Fun "lista" [Const (C 'a'),Fun "lista" []]])

atomo3 :: Atom
atomo3 = ("append",[Fun "lista" [Var "A",Var"X"],Var "Y",Fun "lista" [Var "A",Var "Z"]])

atomo4 :: Atom
atomo4 = ("append",[Fun "lista" [Var "Head",Var "Tail1"],Var "Tail2",Fun "lista" [Const (C 'a'),Fun "list" []]])

atomo5 :: Atom
atomo5 = ("append",[Fun "lista" [],Var "X",Var "X"])

atomo6 :: Atom
atomo6 = ("append",[Var "Tail1",Var "Tail2",Fun "lista" [Const (C 'a'),Fun "list" []]])

--atomo6 :: Atom
--atomo6 =

main :: IO()
main = do
  print $ robinson atomo3 atomo6
  --print $ robinson atomo4 atomo5
  --print $ sustitucion atomo sust_ejem
  --print $ resolucion query app
  --print $ resolucion preg poesia